#!/bin/sh

#
# iptables firewall
#
# @version 0.4.1
# @author falsandtru https://github.com/falsandtru/iptables-firewall/
# @copyright 2014, falsandtru
# @license MIT
#

#----------------------------------------------------------#
# Config                                                   #
#----------------------------------------------------------#

# 管理用ポート番号
LOGIN=0

# IP更新間隔(日)
INTERVAL=7

# IPSの使用
IDSIPS=

# 許可 日本
ACCEPT_COUNTRY_CODE="JP"

# 拒否 中国|香港|マカオ|韓国|北朝鮮
DROP_COUNTRY_CODE="CN|HK|MO|KR|KP"

# 厳格更新
SECURE=

# ブラックリスト/ホワイトリスト
BLACKLIST=
WHITELIST=

# ロール
ROLES=(LOCAL KEEP SYSTEM NETWORK AUTH PRIVATE CUSTOMER PUBLIC)
LOCAL=(IPS ACCEPT)
KEEP=(FIREWALL IPS ACCEPT)
SYSTEM=(/etc/iptables/system FIREWALL FW_INTRUDER IPS ACCEPT)
NETWORK=(/etc/iptables/network FIREWALL FW_INTRUDER IPS ACCEPT)
AUTH=(/etc/iptables/auth COUNTRY_FILTER FIREWALL FW_INTRUDER IPS ACCEPT)
PRIVATE=(/etc/iptables/user COUNTRY_FILTER FIREWALL FW_INTRUDER IPS ACCEPT)
CUSTOMER=(COUNTRY_FILTER FIREWALL IPS ACCEPT)
PUBLIC=(FIREWALL IPS ACCEPT)

# 事前処理/事後処理
PREPROCESS=
POSTPROCESS=

# ログの最大生成間隔
LOG_LIMIT=60/m
LOG_LIMIT_BURST=1000

# コマンド
IPTABLES=iptables

# IPリスト保存先ディレクトリ
CACHE_DIR=/var/cache/iptables/


#----------------------------------------------------------#
# AutoConfig                                               #
#----------------------------------------------------------#

echo "iptables firewall"

# SSHポート
[[ ! $LOGIN -gt 0 ]] && LOGIN=`cat /etc/ssh/sshd_config | grep '^Port ' | tail -n 1 | sed -e 's/^[^0-9]*\([0-9]\+\).*$/\1/'`
echo "LOGIN:		$LOGIN"

# SECURE
if [ -z $SECURE ]; then
    SECURE=false
fi

# IPS/IDS
if [ -z $IDSIPS ]; then
    if [ `ps alx | grep -v grep | grep /snort | head -n 1 | cut -c1` ]; then
        IDSIPS=Snort
    else
        IDSIPS=false
    fi
fi

# IP設定
NAMESERVERS=($(grep '^nameserver' /etc/resolv.conf | cut -d' ' -f2))
NTPSERVERS=($(grep '^server' /etc/ntp.conf | cut -d' ' -f2 | awk '{system("dig +short "$1)}'))


#----------------------------------------------------------#
# Download                                                 #
#----------------------------------------------------------#

WGET="/usr/bin/wget -N --retr-symlinks -P ${CACHE_DIR}"

[ ! -e $CACHE_DIR ] && mkdir -p $CACHE_DIR
if [[ $(find ${CACHE_DIR} -name delegated-*-extended-latest -ctime -$INTERVAL 2>&1) ]]; then
    UPDATE=0
    echo "UPDATE:		NO"
else
    UPDATE=1
    echo "UPDATE:		YES"
    $WGET ftp://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest
    $WGET ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-extended-latest
    $WGET ftp://ftp.apnic.net/pub/stats/apnic/delegated-apnic-extended-latest
    $WGET ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest
    $WGET ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-extended-latest
fi


#----------------------------------------------------------#
# Initialize                                               #
#----------------------------------------------------------#

if [ $UPDATE -ne 0 ] && [[ $(find ${CACHE_DIR} -name delegated-*-extended-latest -mtime -$INTERVAL 2>&1) ]]; then
    RESET=1
    echo "DELETE:	All Chains"
    $IPTABLES -F
    $IPTABLES -X
else
    RESET=0
    for CHAIN in `$IPTABLES -nL | grep ^Chain | cut -d " " -f 2`; do
        if [ COUNTRY_FILTER = $CHAIN ] || [ BLACKLIST_COUNTRY = $CHAIN ]; then continue;fi
        $IPTABLES -F $CHAIN
    done

    for CHAIN in `$IPTABLES -nL | grep ^Chain | cut -d " " -f 2`; do
        if [ COUNTRY_FILTER = $CHAIN ] || [ BLACKLIST_COUNTRY = $CHAIN ]; then continue;fi
        if [ INPUT = $CHAIN ] || [ FORWARD = $CHAIN ] || [ OUTPUT = $CHAIN ]; then continue;fi
        $IPTABLES -X $CHAIN
    done
fi

$IPTABLES -Z
$IPTABLES -P INPUT DROP
$IPTABLES -P OUTPUT DROP
$IPTABLES -P FORWARD DROP

$IPTABLES -N COUNTRY_FILTER 2>/dev/null
$IPTABLES -N BLACKLIST_COUNTRY 2>/dev/null

$IPTABLES -N FIREWALL
$IPTABLES -N FW_BASIC
$IPTABLES -N IPS
$IPTABLES -N IDS


#----------------------------------------------------------#
# Preprocess                                               #
#----------------------------------------------------------#

# PREPROCESS
echo "PREPROCESS:	$PREPROCESS"
`$PREPROCESS`

# ロールチェーン生成
$IPTABLES -N TRACK_PROWLER
for ROLE in ${ROLES[@]}; do
    $IPTABLES -N $ROLE 2>/dev/null
    eval RULES="\${${ROLE}[@]}"
    for RULE in ${RULES[@]}; do
        if [ `echo $RULE | grep -E ^[A-Z_]\+$` ]; then
            $IPTABLES -N $RULE 2>/dev/null
            $IPTABLES -A $ROLE -j $RULE
        elif [ -r $RULE ] || [ $SECURE != false ]; then
            CHAIN=`echo $RULE | awk -F / '{print "file_"$NF}'`
            $IPTABLES -N $CHAIN 2>/dev/null
            $IPTABLES -F $CHAIN
            for LINE in `cat $RULE | grep ^[0-9]`
            do
                $IPTABLES -A $CHAIN -s $LINE -j RETURN
            done
            $IPTABLES -A $CHAIN -j TRACK_PROWLER
            $IPTABLES -A $CHAIN -j DROP
            $IPTABLES -A $ROLE -j $CHAIN
        fi
    done
done

# SECURE
if [ $SECURE != false ]; then
    $IPTABLES -I COUNTRY_FILTER -j DROP
    $IPTABLES -I BLACKLIST_COUNTRY -j DROP
else
    $IPTABLES -I COUNTRY_FILTER -j ACCEPT
    $IPTABLES -I BLACKLIST_COUNTRY -j ACCEPT
fi

# ループバック(自身)のアクセスをすべて許可
$IPTABLES -A INPUT -i lo -j LOCAL
$IPTABLES -A OUTPUT -o lo -j LOCAL
$IPTABLES -A FORWARD -i lo -j LOCAL
$IPTABLES -A FORWARD -o lo -j LOCAL

# 確立した接続を許可
$IPTABLES -A INPUT -m state --state ESTABLISHED,RELATED -j KEEP
$IPTABLES -A OUTPUT -m state --state NEW,ESTABLISHED -j KEEP
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j KEEP

# 名前解決できるようにする
for NAMESERVER in ${NAMESERVERS[@]}; do
    $IPTABLES -A INPUT -s $NAMESERVER -p udp --dport 53 -j SYSTEM
    $IPTABLES -A OUTPUT -d $NAMESERVER -p udp --sport 53 -j SYSTEM
    $IPTABLES -A FORWARD -s $NAMESERVER -p udp --dport 53 -j SYSTEM
    $IPTABLES -A FORWARD -d $NAMESERVER -p udp --sport 53 -j SYSTEM
    echo "NAMESERVER:	$NAMESERVER"
done

# NTPサーバと同期できるようにする
for NTPSERVER in ${NTPSERVERS[@]}; do
    $IPTABLES -A INPUT -s $NTPSERVER -p udp --dport 123 -j SYSTEM
    $IPTABLES -A OUTPUT -d $NTPSERVER -p udp --sport 123 -j SYSTEM
    $IPTABLES -A FORWARD -s $NTPSERVER -p udp --dport 123 -j SYSTEM
    $IPTABLES -A FORWARD -d $NTPSERVER -p udp --sport 123 -j SYSTEM
    echo "NTPSERVER:	$NTPSERVER"
done


#----------------------------------------------------------#
# BLACKLIST/WHITELIST                                      #
#----------------------------------------------------------#

$IPTABLES -N PREFILTER

$IPTABLES -A INPUT -j PREFILTER
$IPTABLES -A FORWARD -j PREFILTER
$IPTABLES -A OUTPUT -j PREFILTER

# ホワイトリストに一致するIPをブラックリスト形式のフィルタから除外する
if [ $WHITELIST ] && [ -s $WHITELIST ]; then
    for LINE in `cat $WHITELIST | grep ^[0-9]`
    do
        $IPTABLES -A PREFILTER -s $LINE -j RETURN
    done
fi

# ブラックリストに一致するIPをDROPする
if [ $BLACKLIST ] && [ -s $BLACKLIST ]; then
    for LINE in `cat $BLACKLIST | grep ^[0-9]`
    do
        $IPTABLES -A PREFILTER -s $LINE -j DROP
    done
fi


#----------------------------------------------------------#
# Firewall                                                 #
#----------------------------------------------------------#

# 送信元IPの偽装防止
sed -i '/net.ipv4.conf.*.rp_filter/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.rp_filter=1 > /dev/null
    echo "net.ipv4.conf.$dev.rp_filter=1" >> /etc/sysctl.conf
done

# ICMP Redirectパケットを拒否
sed -i '/net.ipv4.conf.*.accept_redirects/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.accept_redirects=0 > /dev/null
    echo "net.ipv4.conf.$dev.accept_redirects=0" >> /etc/sysctl.conf
done

# Source Routedパケットを拒否
sed -i '/net.ipv4.conf.*.accept_source_route/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.accept_source_route=0 > /dev/null
    echo "net.ipv4.conf.$dev.accept_source_route=0" >> /etc/sysctl.conf
done

# ブロードキャストアドレス宛pingには応答しない
# ※Smurf攻撃対策
sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1 > /dev/null
sed -i '/net.ipv4.icmp_echo_ignore_broadcasts/d' /etc/sysctl.conf
echo "net.ipv4.icmp_echo_ignore_broadcasts=1" >> /etc/sysctl.conf

# SYN Cookiesを有効にする
# ※TCP SYN Flood攻撃対策
sysctl -w net.ipv4.tcp_syncookies=1 > /dev/null
sed -i '/net.ipv4.tcp_syncookies/d' /etc/sysctl.conf
echo "net.ipv4.tcp_syncookies=1" >> /etc/sysctl.conf

# システムの連続稼働時間を通知しない
# ※カーネルバージョン特定対策
sysctl -w net.ipv4.tcp_timestamps=1 > /dev/null
sed -i '/net.ipv4.tcp_timestamps/d' /etc/sysctl.conf
echo "net.ipv4.tcp_timestamps=1" >> /etc/sysctl.conf

# ブロードキャストパケットをログを記録せずに破棄
$IPTABLES -N DENY_BROADCAST
$IPTABLES -A DENY_BROADCAST -j DROP
$IPTABLES -N FW_BROADCAST 2>/dev/null
$IPTABLES -A FW_BROADCAST -o lo -j RETURN
$IPTABLES -A FW_BROADCAST -o e+ -j RETURN
$IPTABLES -A FW_BROADCAST -o p+ -j RETURN
$IPTABLES -A FW_BROADCAST -o w+ -j RETURN
$IPTABLES -A FW_BROADCAST -m pkttype --pkt-type broadcast -j DENY_BROADCAST
$IPTABLES -A FIREWALL -j FW_BROADCAST && echo "FIREWALL:	DENY_BROADCAST"
$IPTABLES -A FW_BASIC -j FW_BROADCAST

# マルチキャストパケットをログを記録せずに破棄
$IPTABLES -N DENY_MULTICAST
$IPTABLES -A DENY_MULTICAST -j DROP
$IPTABLES -N FW_MULTICAST 2>/dev/null
$IPTABLES -A FW_MULTICAST -o lo -j RETURN
$IPTABLES -A FW_MULTICAST -o e+ -j RETURN
$IPTABLES -A FW_MULTICAST -o p+ -j RETURN
$IPTABLES -A FW_MULTICAST -o w+ -j RETURN
$IPTABLES -A FW_MULTICAST -m pkttype --pkt-type multicast -j DENY_MULTICAST
$IPTABLES -A FIREWALL -j FW_MULTICAST && echo "FIREWALL:	DENY_MULTICAST"
$IPTABLES -A FW_BASIC -j FW_MULTICAST

# 不正なアクセスを行ったIPからのすべてのアクセスをログを記録して破棄
# ※調査的アクセスから公開ポートを隠蔽する
# ※公表サーバーでは無効にしてよい
$IPTABLES -N ANTI_INTRUDER
$IPTABLES -A ANTI_INTRUDER -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES INTRUDER] : '
$IPTABLES -A ANTI_INTRUDER -j DROP
$IPTABLES -N FW_INTRUDER 2>/dev/null
$IPTABLES -A FW_INTRUDER -m state --state ESTABLISHED,RELATED -j RETURN
$IPTABLES -A FW_INTRUDER -i lo -j RETURN
$IPTABLES -A FW_INTRUDER -o lo -j RETURN
$IPTABLES -A FW_INTRUDER -o e+ -j RETURN
$IPTABLES -A FW_INTRUDER -o p+ -j RETURN
$IPTABLES -A FW_INTRUDER -o w+ -j RETURN
# 既知のポートはフィルタしない
$IPTABLES -A FW_INTRUDER -p tcp --dport 0:1023 -j RETURN
$IPTABLES -A FW_INTRUDER -p tcp -m state --state ESTABLISHED,RELATED -j RETURN
$IPTABLES -A FW_INTRUDER -m limit --limit 1000/s --limit-burst 10000 -m recent --name prowler-fast --update --rttl -j ANTI_INTRUDER
$IPTABLES -A FW_INTRUDER -m limit --limit 1000/s --limit-burst 10000 -m recent --name prowler-medium --update --rttl -j ANTI_INTRUDER
$IPTABLES -A FW_INTRUDER -m limit --limit 1000/s --limit-burst 10000 -m recent --name prowler-slow --update --rttl -j ANTI_INTRUDER
# recentモジュールは初期値で100IPしか記憶できない
# 送信元を偽装したパケットを大量に送りつけるか調査元の絶対数が増えると容易に無効化されるため対処されれば効果はない
# 攻撃価値の不明なIPの存在確認とポートスキャンに必要となる最小コストを上げる防御としては有効
# 管理機能を持つサーバーは攻撃価値を特定され本格的な攻撃を受けないよう非公表サーバーに分離隠蔽する必要がある
# $ vi /etc/modprobe.d/iptables-recent.conf
# options ip_list_hash_size=0 xt_recent ip_list_tot=1000
# $ reboot
# $ cat /sys/module/xt_recent/parameters/ip_list_tot
# $ ls /proc/net/xt_recent/

# 不審なアクセスを行っているIPをスパイとして記録
# ※不審なアクセスを長時間追跡する
# ※正規の通信のフィルタとして使用不可
# ※公表サーバーでは無効にしてよい
$IPTABLES -N TRACK_PROWLER 2>/dev/null
$IPTABLES -A TRACK_PROWLER -i lo -j RETURN
$IPTABLES -A TRACK_PROWLER -o lo -j RETURN
$IPTABLES -A TRACK_PROWLER -o e+ -j RETURN
$IPTABLES -A TRACK_PROWLER -o p+ -j RETURN
$IPTABLES -A TRACK_PROWLER -o w+ -j RETURN
$IPTABLES -A TRACK_PROWLER \
          -m recent --name prowler-fast --update --rttl \
          -m hashlimit \
          --hashlimit-name prowler-fast \
          --hashlimit 6/m \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 10000 \
          --hashlimit-htable-max 10000 \
          -j RETURN
$IPTABLES -A TRACK_PROWLER -m recent --name prowler-fast --set
$IPTABLES -A TRACK_PROWLER \
          -m recent --name prowler-medium --update --rttl \
          -m hashlimit \
          --hashlimit-name prowler-medium \
          --hashlimit 1/m \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          --hashlimit-htable-max 10000 \
          -j RETURN
$IPTABLES -A TRACK_PROWLER -m recent --name prowler-medium --set
$IPTABLES -A TRACK_PROWLER \
          -m recent --name prowler-slow --update --rttl \
          -m hashlimit \
          --hashlimit-name prowler-slow \
          --hashlimit 1/h \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 3600000 \
          --hashlimit-htable-max 10000 \
          -j RETURN
$IPTABLES -A TRACK_PROWLER -m recent --name prowler-slow --set

# WANからの送信元がプライベートIPアドレスのパケットをログを記録して破棄してNG
# ※IP spoofing攻撃対策
$IPTABLES -N ANTI_SPOOFING
$IPTABLES -A ANTI_SPOOFING -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SPOOFING] : '
$IPTABLES -A ANTI_SPOOFING -j TRACK_PROWLER
$IPTABLES -A ANTI_SPOOFING -j DROP
$IPTABLES -N FW_SPOOFING 2>/dev/null
$IPTABLES -A FW_SPOOFING -i lo -j RETURN
$IPTABLES -A FW_SPOOFING -o lo -j RETURN
$IPTABLES -A FW_SPOOFING -o e+ -j RETURN
$IPTABLES -A FW_SPOOFING -o p+ -j RETURN
$IPTABLES -A FW_SPOOFING -o w+ -j RETURN
$IPTABLES -A FW_SPOOFING -s 127.0.0.0/8    -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 10.0.0.0/8     -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 172.16.0.0/12  -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 192.168.0.0/16 -j ANTI_SPOOFING
$IPTABLES -A FIREWALL -j FW_SPOOFING && echo "FIREWALL:	ANTI_SPOOFING"
$IPTABLES -A FW_BASIC -j FW_SPOOFING

# 外部とのNetBIOS関連のアクセスはログを記録せずに破棄してNG
$IPTABLES -N DENY_NETBIOS
$IPTABLES -A DENY_NETBIOS -j TRACK_PROWLER
$IPTABLES -A DENY_NETBIOS -j DROP
$IPTABLES -N FW_NETBIOS 2>/dev/null
$IPTABLES -A FW_NETBIOS -p tcp -m multiport --dports 135,137,138,139,445 -j DENY_NETBIOS
$IPTABLES -A FW_NETBIOS -p udp -m multiport --dports 135,137,138,139,445 -j DENY_NETBIOS
$IPTABLES -A FIREWALL -j FW_NETBIOS && echo "FIREWALL:	DENY_NETBIOS"
$IPTABLES -A FW_BASIC -j FW_NETBIOS

# フラグメント化されたパケットをログを記録して破棄してNG
$IPTABLES -N DENY_FRAGMENT
$IPTABLES -A DENY_FRAGMENT -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES FRAGMENT] : '
$IPTABLES -A DENY_FRAGMENT -j TRACK_PROWLER
$IPTABLES -A DENY_FRAGMENT -j DROP
$IPTABLES -N FW_FRAGMENT 2>/dev/null
$IPTABLES -A FW_FRAGMENT -i lo -j RETURN
$IPTABLES -A FW_FRAGMENT -o lo -j RETURN
$IPTABLES -A FW_FRAGMENT -o e+ -j RETURN
$IPTABLES -A FW_FRAGMENT -o p+ -j RETURN
$IPTABLES -A FW_FRAGMENT -o w+ -j RETURN
$IPTABLES -A FW_FRAGMENT -f -j DENY_FRAGMENT
$IPTABLES -A FIREWALL -j FW_FRAGMENT && echo "FIREWALL:	DENY_FRAGMENT"

# 不正なパケットをログを記録して破棄してNG
$IPTABLES -N DENY_INVALID
$IPTABLES -A DENY_INVALID -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES INVALID] : '
$IPTABLES -A DENY_INVALID -j DROP
$IPTABLES -N FW_INVALID 2>/dev/null
$IPTABLES -A FW_INVALID -i lo -j RETURN
$IPTABLES -A FW_INVALID -o lo -j RETURN
$IPTABLES -A FW_INVALID -o e+ -j RETURN
$IPTABLES -A FW_INVALID -o p+ -j RETURN
$IPTABLES -A FW_INVALID -o w+ -j RETURN
$IPTABLES -A FW_INVALID -m state --state INVALID -j DENY_INVALID
$IPTABLES -A FIREWALL -j FW_INVALID && echo "FIREWALL:	DENY_INVALID"

# フラグの不正なパケットを破棄、1時間に3回を超えたらログを記録してNG
# ※ステルススキャン対策
# ※既知のポートはもともと隠密性がないため保護せず誤作動の回避を優先
# ※SSHの終了処理をしないで切断されると簡単に自爆するので注意
# ※FW_PORTSCANとFW_INTRUDERが機能しているうちは有効にする必要性は低い
# ※フラグパターンの妥当性未検証
# ※公表サーバーでは無効にしてよい
$IPTABLES -N ANTI_STEALTHSCAN
$IPTABLES -A ANTI_STEALTHSCAN -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES STEALTHSCAN] : '
$IPTABLES -A ANTI_STEALTHSCAN \
          -m hashlimit \
          --hashlimit-name scan \
          --hashlimit 1/h \
          --hashlimit-burst 3 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 960000 \
          -j DROP
$IPTABLES -A ANTI_STEALTHSCAN -j TRACK_PROWLER
$IPTABLES -A ANTI_STEALTHSCAN -j DROP
$IPTABLES -N FW_STEALTHSCAN 2>/dev/null
$IPTABLES -A FW_STEALTHSCAN -i lo -j RETURN
$IPTABLES -A FW_STEALTHSCAN -o lo -j RETURN
$IPTABLES -A FW_STEALTHSCAN -o e+ -j RETURN
$IPTABLES -A FW_STEALTHSCAN -o p+ -j RETURN
$IPTABLES -A FW_STEALTHSCAN -o w+ -j RETURN
$IPTABLES -A FW_STEALTHSCAN ! -p tcp -j RETURN
$IPTABLES -A FW_STEALTHSCAN -p tcp --dport 0:1023 -j RETURN
$IPTABLES -A FW_STEALTHSCAN -p tcp -m state ! --state NEW -j RETURN
# SYN + ACK when NEW
$IPTABLES -A FW_STEALTHSCAN -p tcp -m state --state NEW --tcp-flags SYN,ACK SYN,ACK -j ANTI_STEALTHSCAN
# FIN/PSH/URG without ACK
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,FIN FIN -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,PSH PSH -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,URG URG -j ANTI_STEALTHSCAN
# SYN + FIN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags SYN,FIN SYN,FIN -j ANTI_STEALTHSCAN
# SYN + RST
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags SYN,RST SYN,RST -j ANTI_STEALTHSCAN
# FIN + RST
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags FIN,RST FIN,RST -j ANTI_STEALTHSCAN
# ALL
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL ALL -j ANTI_STEALTHSCAN
# nmap Null scans / no flags
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL NONE -j ANTI_STEALTHSCAN
# nmap FIN stealth scan
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL FIN -j ANTI_STEALTHSCAN
# FIN + URG + PSH
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL FIN,PSH,URG -j ANTI_STEALTHSCAN
# XMAS
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG,PSH -j ANTI_STEALTHSCAN
$IPTABLES -A FIREWALL -j FW_STEALTHSCAN && echo "FIREWALL:	ANTI_STEALTHSCAN"

# pingは1秒間に4回を超えたらログを記録して破棄してNG
# ※Ping of Death攻撃対策
$IPTABLES -N ANTI_PINGDEATH
$IPTABLES -A ANTI_PINGDEATH \
          -m hashlimit \
          --hashlimit-name ping \
          --hashlimit 1/s \
          --hashlimit-burst 4 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 1000 \
          -j RETURN
$IPTABLES -A ANTI_PINGDEATH -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES PINGDEATH] : '
$IPTABLES -A ANTI_PINGDEATH -j TRACK_PROWLER
$IPTABLES -A ANTI_PINGDEATH -j DROP
$IPTABLES -N FW_PINGDEATH 2>/dev/null
$IPTABLES -A FW_PINGDEATH -i lo -j RETURN
$IPTABLES -A FW_PINGDEATH -o lo -j RETURN
$IPTABLES -A FW_PINGDEATH -o e+ -j RETURN
$IPTABLES -A FW_PINGDEATH -o p+ -j RETURN
$IPTABLES -A FW_PINGDEATH -o w+ -j RETURN
$IPTABLES -A FW_PINGDEATH -p icmp --icmp-type echo-request -j ANTI_PINGDEATH
$IPTABLES -A FIREWALL -j FW_PINGDEATH && echo "FIREWALL:	ANTI_PINGDEATH"

# 過大なアクセスをIP単位で制限
# ※SYN Flood攻撃対策(数値は適宜調整)
#
# -m hashlimit                 ：hashlimitモジュールを利用
# --hashlimit-name name        ：ハッシュテーブル名
# --hashlimit n                ：パケット回復量
# --hashlimit-burst n          ：パケット容量
# --hashlimit-mode hash        ：同一アクセスとしてカウントする識別基準
# --hashlimit-htable-expire ms ：ハッシュテーブル内のレコードの有効期間(単位：ミリ秒)
#
# HTTPポートへの過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_SYNFLOOD
$IPTABLES -A ANTI_SYNFLOOD \
          -m hashlimit \
          --hashlimit-name http \
          --hashlimit 10/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_SYNFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SYNFLOOD] : '
$IPTABLES -A ANTI_SYNFLOOD -j DROP
$IPTABLES -N FW_SYNFLOOD 2>/dev/null
$IPTABLES -A FW_SYNFLOOD -i lo -j RETURN
$IPTABLES -A FW_SYNFLOOD -o lo -j RETURN
$IPTABLES -A FW_SYNFLOOD -o e+ -j RETURN
$IPTABLES -A FW_SYNFLOOD -o p+ -j RETURN
$IPTABLES -A FW_SYNFLOOD -o w+ -j RETURN
$IPTABLES -A FW_SYNFLOOD -p tcp --dport 80 -m state --state NEW -j ANTI_SYNFLOOD
$IPTABLES -A FIREWALL -j FW_SYNFLOOD && echo "FIREWALL:	ANTI_SYNFLOOD"
#
# HTTPSポートへの過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_SYNFLOOD_SSL
$IPTABLES -A ANTI_SYNFLOOD_SSL \
          -m hashlimit \
          --hashlimit-name https \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_SYNFLOOD_SSL -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SYNFLOOD(SSL)] : '
$IPTABLES -A ANTI_SYNFLOOD_SSL -j DROP
$IPTABLES -N FW_SYNFLOOD_SSL 2>/dev/null
$IPTABLES -A FW_SYNFLOOD_SSL -i lo -j RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -o lo -j RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -o e+ -j RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -o p+ -j RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -o w+ -j RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -p tcp --dport 443 -m state --state NEW -j ANTI_SYNFLOOD_SSL
$IPTABLES -A FIREWALL -j FW_SYNFLOOD_SSL && echo "FIREWALL:	ANTI_SYNFLOOD_SSL"
#
# UDPによる過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_UDPFLOOD
$IPTABLES -A ANTI_UDPFLOOD \
          -m hashlimit \
          --hashlimit-name udp \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_UDPFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES UDPFLOOD] : '
$IPTABLES -A ANTI_UDPFLOOD -j DROP
$IPTABLES -N FW_UDPFLOOD 2>/dev/null
$IPTABLES -A FW_UDPFLOOD -i lo -j RETURN
$IPTABLES -A FW_UDPFLOOD -o lo -j RETURN
$IPTABLES -A FW_UDPFLOOD -o e+ -j RETURN
$IPTABLES -A FW_UDPFLOOD -o p+ -j RETURN
$IPTABLES -A FW_UDPFLOOD -o w+ -j RETURN
$IPTABLES -A FW_UDPFLOOD -p udp -m state --state NEW -j ANTI_UDPFLOOD
$IPTABLES -A FIREWALL -j FW_UDPFLOOD && echo "FIREWALL:	ANTI_UDPFLOOD"
#
# ICMPによる過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_ICMPFLOOD
$IPTABLES -A ANTI_ICMPFLOOD \
          -m hashlimit \
          --hashlimit-name icmp \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_ICMPFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES ICMPFLOOD] : '
$IPTABLES -A ANTI_ICMPFLOOD -j DROP
$IPTABLES -N FW_ICMPFLOOD 2>/dev/null
$IPTABLES -A FW_ICMPFLOOD -i lo -j RETURN
$IPTABLES -A FW_ICMPFLOOD -o lo -j RETURN
$IPTABLES -A FW_ICMPFLOOD -o e+ -j RETURN
$IPTABLES -A FW_ICMPFLOOD -o p+ -j RETURN
$IPTABLES -A FW_ICMPFLOOD -o w+ -j RETURN
$IPTABLES -A FW_ICMPFLOOD -p icmp -j ANTI_ICMPFLOOD
$IPTABLES -A FIREWALL -j FW_ICMPFLOOD && echo "FIREWALL:	ANTI_ICMPFLOOD"

# 管理用ポートへ3分間に10回を超えて接続試行をログを記録して破棄してNG
# ※Brute Force攻撃対策
$IPTABLES -N ANTI_BRUTEFORCE
$IPTABLES -A ANTI_BRUTEFORCE \
          -m hashlimit \
          --hashlimit-name bruteforce \
          --hashlimit 1/m \
          --hashlimit-burst 7 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 180000 \
          -j RETURN
$IPTABLES -A ANTI_BRUTEFORCE -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES BRUTEFORCE] : '
$IPTABLES -A ANTI_BRUTEFORCE -j TRACK_PROWLER
$IPTABLES -A ANTI_BRUTEFORCE -j DROP
$IPTABLES -N FW_BRUTEFORCE 2>/dev/null
$IPTABLES -A FW_BRUTEFORCE -i lo -j RETURN
$IPTABLES -A FW_BRUTEFORCE -o lo -j RETURN
$IPTABLES -A FW_BRUTEFORCE -o e+ -j RETURN
$IPTABLES -A FW_BRUTEFORCE -o p+ -j RETURN
$IPTABLES -A FW_BRUTEFORCE -o w+ -j RETURN
$IPTABLES -A FW_BRUTEFORCE -p tcp -m multiport --dports $LOGIN -m state --syn --state NEW -j ANTI_BRUTEFORCE
$IPTABLES -A FIREWALL -j FW_BRUTEFORCE && echo "FIREWALL:	ANTI_BRUTEFORCE"
$IPTABLES -A FW_BASIC -j FW_BRUTEFORCE


#----------------------------------------------------------#
# IDS/IPS                                                  #
#----------------------------------------------------------#

$IPTABLES -F IPS
$IPTABLES -F IDS
if [ $IDSIPS = Snort ]; then

    # ICMP通信をすべて解析
    $IPTABLES -A IPS -p icmp -j NFQUEUE --queue-num 2

    # UDP通信をすべて解析
    $IPTABLES -A IPS -p udp -j NFQUEUE --queue-num 2

    # TCP通信を解析
    #$IPTABLES -A IPS -o eth+ -p tcp -j ACCEPT
    #$IPTABLES -A IPS -o en+ -p tcp -j ACCEPT
    $IPTABLES -A IPS -p tcp -j NFQUEUE --queue-num 2

    # バックエンドサーバーとの内部通信を解析
    #$IPTABLES -A IPS -i lo -p tcp --dport 9000 -j NFQUEUE --queue-num 2
    #$IPTABLES -A IPS -o lo -p tcp --dport 9000 -j NFQUEUE --queue-num 2

    echo "IDS/IPS:	Snort"

else
    echo "IDS/IPS:	DISABLE"
fi


#----------------------------------------------------------#
# CountryFilter                                            #
#----------------------------------------------------------#

CIDR_COUNT_LIST=()
declare -A CIDR_TABLE
for ((CIDR=32;0<CIDR;CIDR--))
do
    CIDR_COUNT=$((2**(32-$CIDR)))
    CIDR_COUNT_LIST=($CIDR_COUNT "${CIDR_COUNT_LIST[@]}")
    CIDR_TABLE[$CIDR_COUNT]=$CIDR
done

COUNT_TO_CIDR(){
    local COUNT=$1
    local CIDR_COUNT
    for CIDR_COUNT in ${CIDR_COUNT_LIST[@]}
    do
        if [ $CIDR_COUNT -gt $COUNT ]; then continue;fi
        local CIDR=${CIDR_TABLE[$CIDR_COUNT]}
        break
    done
    echo $CIDR
}
CIDR_TO_COUNT(){
    local CIDR=$1
    local COUNT=$((2**(32-$CIDR)))
    echo $COUNT
}
SHIFT_ADDR(){
    local ADDR=$1
    local COUNT=$2
    local D1=$(($COUNT/(256**3)))
    [ $D1 -ne 0 ] && COUNT=0
    local D2=$(($COUNT/(256**2)))
    [ $D2 -ne 0 ] && COUNT=0
    local D3=$(($COUNT/(256**1)))
    [ $D3 -ne 0 ] && COUNT=0
    local D4=$(($COUNT/(256**0)))
    ADDR=`echo $ADDR | awk -v D1=$D1 -v D2=$D2 -v D3=$D3 -v D4=$D4 -F"." '{ print $1+D1 "." $2+D2 "." $3+D3 "." $4+D4 }'`
    # IPの数値が255を超えた場合のIPの繰り上げ処理とこれに付随するサブネットマスクの分割処理を実装していないため当該処理が必要な場合は当該部分において正常に動作しない。
    # レジストリの公開しているIP割り当てリストでは繰り上がり処理が必要となる項目は見受けられなかったためこれらの処理を省略する。
    echo $ADDR
}

BUILD_COUNTRY(){
    if [ ! -s $CACHE_DIR$1 ] || [ ! $2 -a ! $3 ];then return;fi
    echo "LOAD:	$1"
    local LINE
    for LINE in `cat $CACHE_DIR$1 | grep -E "\|($2|$3)\|ipv4\|"`
    do
        local CODE=`echo $LINE | cut -d "|" -f 2`
        local ADDR=`echo $LINE | cut -d "|" -f 4`
        local COUNT=`echo $LINE | cut -d "|" -f 5`
        local CIDR=32
        if [ $2 ] && [ `echo $CODE | grep -E $2` ]; then
            BUILD_COUNTRY_RULE $ADDR $COUNT BUILD_COUNTRY_RULE_ACCEPT
            printf "%-10s%-4s%-20s%s\n" ACCEPT $CODE $ADDR/$? $LINE
        elif [ $3 ] && [ `echo $CODE | grep -E $3` ]; then
            BUILD_COUNTRY_RULE $ADDR $COUNT BUILD_COUNTRY_RULE_DROP
            printf "%-10s%-4s%-20s%s\n" DROP   $CODE $ADDR/$? $LINE
        fi
    done
}
BUILD_COUNTRY_RULE(){
    local ADDR=$1
    local COUNT=$2
    local CALLBACK=$3
    local CIDR=`COUNT_TO_CIDR $COUNT`
    eval "$CALLBACK $ADDR $CIDR"

    local REM=$(($COUNT-`CIDR_TO_COUNT $CIDR`))
    if [ $REM -gt 0 ]; then
        ADDR=`SHIFT_ADDR $ADDR $(CIDR_TO_COUNT $CIDR)`
        BUILD_COUNTRY_RULE $ADDR $REM $CALLBACK
    fi
    return $CIDR
}
BUILD_COUNTRY_RULE_ACCEPT(){
    local ADDR=$1
    local CIDR=$2
    $IPTABLES -A COUNTRY_FILTER -s $ADDR/$CIDR -j RETURN
}
BUILD_COUNTRY_RULE_DROP(){
    local ADDR=$1
    local CIDR=$2
    $IPTABLES -A BLACKLIST_COUNTRY -s $ADDR/$CIDR -j DROP
}

if [ $RESET -ne 0 ] || [ ! -z "$ACCEPT_COUNTRY_CODE" -a $($IPTABLES -S COUNTRY_FILTER 2>/dev/null | awk 'END{print NR}') -le 2 ] || [ ! -z "$DROP_COUNTRY_CODE" -a $($IPTABLES -S BLACKLIST_COUNTRY 2>/dev/null | awk 'END{print NR}') -le 2 ]; then
    echo "BUILD:		Chain COUNTRY_FILTER"
    echo "BUILD:		Chain BLACKLIST_COUNTRY"

    $IPTABLES -F COUNTRY_FILTER 2>/dev/null
    $IPTABLES -F BLACKLIST_COUNTRY 2>/dev/null

    BUILD_COUNTRY "delegated-apnic-extended-latest"   $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-arin-extended-latest"    $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-ripencc-extended-latest" $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-lacnic-extended-latest"  $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-afrinic-extended-latest" $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE

    $IPTABLES -A COUNTRY_FILTER -j DROP
else
    [ $ACCEPT_COUNTRY_CODE ] && echo "REUSE:		Chain COUNTRY_FILTER"
    [ $DROP_COUNTRY_CODE ] && echo "REUSE:		Chain BLACKLIST_COUNTRY"
fi

if [ $DROP_COUNTRY_CODE ]; then
    $IPTABLES -A PREFILTER -j BLACKLIST_COUNTRY
fi


#----------------------------------------------------------#
# Port                                                     #
#----------------------------------------------------------#

# 最小限のICMPのみ許可
$IPTABLES -A INPUT -p icmp --icmp-type destination-unreachable -j SYSTEM && echo "ICMP:		SYSTEM			INPUT[ICMP:DestinationUnreachable]"
$IPTABLES -A INPUT -p icmp --icmp-type source-quench -j SYSTEM && echo "ICMP:		SYSTEM			INPUT[ICMP:SourceQuench]"
$IPTABLES -A INPUT -p icmp --icmp-type redirect -j SYSTEM && echo "ICMP:		SYSTEM			INPUT[ICMP:Redirect]"
$IPTABLES -A INPUT -p icmp --icmp-type time-exceeded -j SYSTEM && echo "ICMP:		SYSTEM			INPUT[ICMP:TimeExceeded]"
$IPTABLES -A INPUT -p icmp --icmp-type parameter-problem -j SYSTEM && echo "ICMP:		SYSTEM			INPUT[ICMP:ParameterProblem]"

# DNS[TCP/UDP:53]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 53 -j SYSTEM && echo "DNS:		SYSTEM			INPUT[TCP:53]"
#$IPTABLES -A INPUT -p udp --dport 53 -j SYSTEM && echo "DNS:		SYSTEM			INPUT[UDP:53]"

# 管理用ポート(SSH等)を開放
$IPTABLES -A INPUT -p tcp -m multiport --dports $LOGIN -j AUTH && echo "AUTH:		AUTH			INPUT[TCP:XXX]"

# SNMP[UDP:160,161]ポートを開放AUTH
#$IPTABLES -A INPUT -p udp --dport 160 -j SYSTEM && echo "SNMP:		SYSTEM			INPUT[UDP:160]"
#$IPTABLES -A INPUT -p udp --dport 161 -j SYSTEM && echo "SNMP:		SYSTEM			INPUT[UDP:161]"

# HTTP[TCP:80]ポートを開放
$IPTABLES -A INPUT -p tcp --dport 80 -j PUBLIC && echo "HTTP:		PUBLIC			INPUT[TCP:80]"

# HTTPS[TCP:443]ポートを開放
$IPTABLES -A INPUT -p tcp --dport 443 -j CUSTOMER && echo "HTTPS:		CUSTOMER		INPUT[TCP:443]"

# FTP[TCP:21]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 21 -j PRIVATE && echo "FTP:		PRIVATE			INPUT[TCP:21]"

# PASV(FTP-DATA)ポートを開放 ※PASV用ポート60000:60030は設定例
#$IPTABLES -A INPUT -p tcp --dport 60000:60030 -j PRIVATE && echo "PASV:		PRIVATE			INPUT[TCP:60000-60030]"

# IDENT[TCP:113]ポートを開放
# ※IDENTを使用せずメールサーバーを公開する場合はメールサーバ等のレスポンス低下防止のため拒否応答
#$IPTABLES -A INPUT -p tcp --dport 113 -j PRIVATE && echo "IDENT:		PRIVATE			INPUT[TCP:113]"
#$IPTABLES -A INPUT -p tcp --dport 113 -j REJECT --reject-with tcp-reset && echo "IDENT:		REJECT			INPUT[TCP:113]"

# SMTP[TCP:25]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 25 -j PRIVATE && echo "SMTP:		PRIVATE			INPUT[TCP:25]"

# SMTPS[TCP:465]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 465 -j AUTH && echo "SMTPS:		AUTH			INPUT[TCP:465]"

# POP3[TCP:110]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 110 -j PRIVATE && echo "POP3:		PRIVATE			INPUT[TCP:110]"

# POP3S[TCP:995]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 995 -j AUTH && echo "POP3S:		AUTH			INPUT[TCP:995]"

# IMAP[TCP:143]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 143 -j PRIVATE && echo "IMAP:		PRIVATE			INPUT[TCP:143]"

# IMAPS[TCP:993]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 993 -j AUTH && echo "IMAPS:		AUTH			INPUT[TCP:993]"

# OpenVPN[UDP:1194]ポートを開放
#$IPTABLES -A INPUT -p udp --dport 1194 -j AUTH && echo "OpenVPN:		AUTH			INPUT[UDP:1194]"

# IPsec[TCP/UDP:50,51]ポートを開放
#$IPTABLES -A INPUT -p 50 -j AUTH && echo "IPsec:		AUTH			INPUT[TCP/UDP:50]"
#$IPTABLES -A INPUT -p 51 -j AUTH && echo "IPsec:		AUTH			INPUT[TCP/UDP:51]"

# Submission[TCP:587]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 587 -j PRIVATE && echo "Submission:		PRIVATE			INPUT[TCP:587]"

# VPNインタフェース用ファイアウォール設定
#[ -f /etc/openvpn/openvpn-startup ] && /etc/openvpn/openvpn-startup


#----------------------------------------------------------#
# Postprocess                                               #
#----------------------------------------------------------#

# 一時設定を削除
$IPTABLES -D COUNTRY_FILTER 1 2>/dev/null
$IPTABLES -D BLACKLIST_COUNTRY 1 2>/dev/null

# 公開していないポートへのパケットをログを記録して破棄してNG
# ※ポートスキャン対策
# ※開けていないポートに1度でも触ったらアウト
# ※公表サーバーでは無効にしてよい
$IPTABLES -N TRAP_PORTSCAN
$IPTABLES -A TRAP_PORTSCAN -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES PORTSCAN] : '
$IPTABLES -A TRAP_PORTSCAN -j TRACK_PROWLER
$IPTABLES -A TRAP_PORTSCAN -j DROP
$IPTABLES -N FW_PORTSCAN
$IPTABLES -A FW_PORTSCAN -i lo -j RETURN
$IPTABLES -A FW_PORTSCAN -o lo -j RETURN
$IPTABLES -A FW_PORTSCAN -o e+ -j RETURN
$IPTABLES -A FW_PORTSCAN -o p+ -j RETURN
$IPTABLES -A FW_PORTSCAN -o w+ -j RETURN
$IPTABLES -A FW_PORTSCAN -j FW_BROADCAST
$IPTABLES -A FW_PORTSCAN -j FW_MULTICAST
$IPTABLES -A FW_PORTSCAN -j TRAP_PORTSCAN
$IPTABLES -A INPUT -j FW_PORTSCAN && echo "FIREWALL:	TRAP_PORTSCAN"
$IPTABLES -A FORWARD -j FW_PORTSCAN && echo "FIREWALL:	TRAP_PORTSCAN"

# POSTPROCESS
echo "POSTPROCESS:	$POSTPROCESS"
`$POSTPROCESS`


#----------------------------------------------------------#
# Finalize                                                 #
#----------------------------------------------------------#

# 設定保存(/etc/sysconfig/iptablesの既存の設定は削除)
service iptables save
sysctl -p 2>&1 | grep -v -E "^error:.*(ipv6|bridge-nf-call)"
service rsyslog restart

echo complete
