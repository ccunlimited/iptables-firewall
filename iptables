#!/bin/sh

#
# iptables firewall
#
# @version 0.2.2
# @author falsandtru https://github.com/falsandtru/iptables-firewall/
# @copyright 2014, falsandtru
# @license MIT
#

#----------------------------------------------------------#
# Config                                                   #
#----------------------------------------------------------#

# 管理用ポート番号
LOGIN=0

# IPの更新間隔(日)
INTERVAL=7

# インタフェース名定義
LAN=eth0

# IPSの使用
IPS=

# 許可 日本
ACCEPT_COUNTRY_CODE="JP"

# 拒否 中国|香港|マカオ|韓国|北朝鮮
DROP_COUNTRY_CODE="CN|HK|MO|KR|KP"

# ブラックリスト/ホワイトリスト/グレーリスト
BLACKLIST=
GRAYLIST=
WHITELIST=

# 厳格更新
SECURE=false

# ログの最大生成間隔
LOG_LIMIT=6/m
LOG_LIMIT_BURST=1000

# コマンド
IPTABLES=iptables

# IPリスト保存先ディレクトリ
CACHE_DIR=/var/cache/iptables/


#----------------------------------------------------------#
# AutoConfig                                               #
#----------------------------------------------------------#

echo "iptables firewall"

# SSHポート
[[ ! $LOGIN -gt 0 ]] && LOGIN=`cat /etc/ssh/sshd_config | grep '^Port ' | tail -n 1 | sed -e 's/^[^0-9]*\([0-9]\+\).*$/\1/'`
echo "LOGIN:		$LOGIN"

# IPS/IDS
if [ ! $IPS ] || [ $IPS != false ]; then
    if [ `ps alx | grep -v grep | grep /snort | head -n 1 | cut -c1` ]; then
        IPS=Snort
    else
        IPS=false
    fi
fi

LOCALNET_MASK=`ifconfig $LAN|sed -e 's/^.*Mask:\([^ ]*\)$/\1/p' -e d`

# 内部ネットワークのネットマスク取得
LOCALNET_MASK=`ifconfig $LAN|sed -e 's/^.*Mask:\([^ ]*\)$/\1/p' -e d`

# 内部ネットワークアドレス取得
LOCALNET_ADDR=`netstat -rn|grep $LAN|grep $LOCALNET_MASK|cut -f1 -d' '`
LOCALNET=$LOCALNET_ADDR/$LOCALNET_MASK

# IP設定
NAMESERVERS=($(grep '^nameserver' /etc/resolv.conf | cut -d' ' -f2))
NTPSERVERS=($(grep '^server' /etc/ntp.conf | cut -d' ' -f2 | awk '{system("dig +short "$1)}'))


#----------------------------------------------------------#
# Download                                                 #
#----------------------------------------------------------#

WGET="/usr/bin/wget -N --retr-symlinks -P ${CACHE_DIR}"

if [[ $(find ${CACHE_DIR} -name delegated-*-extended-latest -ctime -$INTERVAL 2>&1) ]]; then
    UPDATE=0
    echo "UPDATE:		NO"
else
    UPDATE=1
    echo "UPDATE:		YES"
    $WGET ftp://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest
    $WGET ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-extended-latest
    $WGET ftp://ftp.apnic.net/pub/stats/apnic/delegated-apnic-extended-latest
    $WGET ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest
    $WGET ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-extended-latest
fi


#----------------------------------------------------------#
# Initialize                                               #
#----------------------------------------------------------#

if [ $UPDATE -ne 0 ] && [[ $(find ${CACHE_DIR} -name delegated-*-extended-latest -mtime -$INTERVAL 2>&1) ]]; then
    RESET=1
    echo "DELETE:	All Chains"
    $IPTABLES -F
    $IPTABLES -X
else
    RESET=0
    for CHAIN in `$IPTABLES -nL | grep ^Chain | cut -d " " -f 2`; do
        if [ COUNTRY_FILTER = $CHAIN ] || [ BLACKLIST_COUNTRY = $CHAIN ]; then continue;fi
        $IPTABLES -F $CHAIN
    done

    for CHAIN in `$IPTABLES -nL | grep ^Chain | cut -d " " -f 2`; do
        if [ FIREWALL = $CHAIN ]; then continue;fi
        if [ COUNTRY_FILTER = $CHAIN ] || [ BLACKLIST_COUNTRY = $CHAIN ]; then continue;fi
        if [ INPUT = $CHAIN ] || [ FORWARD = $CHAIN ] || [ OUTPUT = $CHAIN ]; then continue;fi
        $IPTABLES -X $CHAIN
    done
fi

$IPTABLES -Z
$IPTABLES -P INPUT DROP
$IPTABLES -P OUTPUT DROP
$IPTABLES -P FORWARD DROP

$IPTABLES -N OUTBOUND_RETURN
$IPTABLES -A OUTBOUND_RETURN -o lo -j RETURN
$IPTABLES -A OUTBOUND_RETURN -o eth+ -j RETURN
$IPTABLES -A OUTBOUND_RETURN -o ppp+ -j RETURN
$IPTABLES -N INBOUND_RETURN
$IPTABLES -A INBOUND_RETURN -i lo -j RETURN
$IPTABLES -A INBOUND_RETURN -i eth+ -j RETURN
$IPTABLES -A INBOUND_RETURN -i ppp+ -j RETURN

$IPTABLES -N FIREWALL 2>/dev/null


#----------------------------------------------------------#
# Preprocess                                               #
#----------------------------------------------------------#

if [ $SECURE = true ]; then
    $IPTABLES -A FIREWALL -j DROP
else
    $IPTABLES -A FIREWALL -j ACCEPT
fi

# ループバック(自身)のアクセスをすべて許可
$IPTABLES -A INPUT -i lo -j FIREWALL
$IPTABLES -A OUTPUT -o lo -j FIREWALL
$IPTABLES -A FORWARD -i lo -j FIREWALL
$IPTABLES -A FORWARD -o lo -j FIREWALL

# 確立した接続を切断しない
$IPTABLES -A INPUT -m state --state ESTABLISHED,RELATED -j FIREWALL
$IPTABLES -A OUTPUT -m state --state NEW,ESTABLISHED -j FIREWALL
$IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j FIREWALL

# 名前解決できるようにする
for nameserver in ${NAMESERVERS[@]}; do
    $IPTABLES -A INPUT -s $nameserver -p udp --dport 53 -j FIREWALL
    $IPTABLES -A OUTPUT -d $nameserver -p udp --sport 53 -j FIREWALL
    $IPTABLES -A FORWARD -s $nameserver -p udp --dport 53 -j FIREWALL
    $IPTABLES -A FORWARD -d $nameserver -p udp --sport 53 -j FIREWALL
    echo "NAMESERVER:	$nameserver"
done

# NTPサーバと同期できるようにする
for ntpserver in ${NTPSERVERS[@]}; do
    $IPTABLES -A INPUT -s $ntpserver -p udp --dport 123 -j FIREWALL
    $IPTABLES -A OUTPUT -d $ntpserver -p udp --sport 123 -j FIREWALL
    $IPTABLES -A FORWARD -s $ntpserver -p udp --dport 123 -j FIREWALL
    $IPTABLES -A FORWARD -d $ntpserver -p udp --sport 123 -j FIREWALL
    echo "NTPSERVER:	$ntpserver"
done


#----------------------------------------------------------#
# CountryFilter                                            #
#----------------------------------------------------------#

CIDR_COUNT_LIST=()
declare -A CIDR_TABLE
for ((CIDR=32;0<CIDR;CIDR--))
do
    CIDR_COUNT=$((2**(32-$CIDR)))
    CIDR_COUNT_LIST=($CIDR_COUNT "${CIDR_COUNT_LIST[@]}")
    CIDR_TABLE[$CIDR_COUNT]=$CIDR
done

COUNT_TO_CIDR(){
    local COUNT=$1
    local CIDR_COUNT
    for CIDR_COUNT in ${CIDR_COUNT_LIST[@]}
    do
        if [ $CIDR_COUNT -gt $COUNT ]; then continue;fi
        local CIDR=${CIDR_TABLE[$CIDR_COUNT]}
        break
    done
    echo $CIDR
}
CIDR_TO_COUNT(){
    local CIDR=$1
    local COUNT=$((2**(32-$CIDR)))
    echo $COUNT
}
SHIFT_ADDR(){
    local ADDR=$1
    local COUNT=$2
    local D1=$(($COUNT/(256**3)))
    [ $D1 -ne 0 ] && COUNT=0
    local D2=$(($COUNT/(256**2)))
    [ $D2 -ne 0 ] && COUNT=0
    local D3=$(($COUNT/(256**1)))
    [ $D3 -ne 0 ] && COUNT=0
    local D4=$(($COUNT/(256**0)))
    ADDR=`echo $ADDR | awk -v D1=$D1 -v D2=$D2 -v D3=$D3 -v D4=$D4 -F"." '{ print $1+D1 "." $2+D2 "." $3+D3 "." $4+D4 }'`
    # IPの数値が255を超えた場合のIPの繰り上げ処理とこれに付随するサブネットマスクの分割処理を実装していないため当該処理が必要な場合は当該部分において正常に動作しない。
    # レジストリの公開しているIP割り当てリストでは繰り上がり処理が必要となる項目は見受けられなかったためこれらの処理を省略する。
    echo $ADDR
}

BUILD_COUNTRY(){
    if [ ! -s $CACHE_DIR$1 ] || [ ! $2 ] || [ ! $3 ];then return;fi
    echo "LOAD:	$1"
    local LINE
    for LINE in `cat $CACHE_DIR$1 | grep -E "\|($2|$3)\|ipv4\|"`
    do
        local CODE=`echo $LINE | cut -d "|" -f 2`
        local ADDR=`echo $LINE | cut -d "|" -f 4`
        local COUNT=`echo $LINE | cut -d "|" -f 5`
        local CIDR=32
        if [ `echo $CODE | grep -E $2` ]; then
            BUILD_COUNTRY_RULE $ADDR $COUNT BUILD_COUNTRY_RULE_ACCEPT
            printf "%-10s%-4s%-20s%s\n" ACCEPT $CODE $ADDR/$? $LINE
        elif [ `echo $CODE | grep -E $3` ]; then
            BUILD_COUNTRY_RULE $ADDR $COUNT BUILD_COUNTRY_RULE_DROP
            printf "%-10s%-4s%-20s%s\n" DROP   $CODE $ADDR/$? $LINE
        fi
    done
}
BUILD_COUNTRY_RULE(){
    local ADDR=$1
    local COUNT=$2
    local CALLBACK=$3
    local CIDR=`COUNT_TO_CIDR $COUNT`
    eval "$CALLBACK $ADDR $CIDR"

    local REM=$(($COUNT-`CIDR_TO_COUNT $CIDR`))
    if [ $REM -gt 0 ]; then
        ADDR=`SHIFT_ADDR $ADDR $(CIDR_TO_COUNT $CIDR)`
        BUILD_COUNTRY_RULE $ADDR $REM $CALLBACK
    fi
    return $CIDR
}
BUILD_COUNTRY_RULE_ACCEPT(){
    local ADDR=$1
    local CIDR=$2
    $IPTABLES -A COUNTRY_FILTER -s $ADDR/$CIDR -j FIREWALL
}
BUILD_COUNTRY_RULE_DROP(){
    local ADDR=$1
    local CIDR=$2
    $IPTABLES -A BLACKLIST_COUNTRY -s $ADDR/$CIDR -j DROP
}

if [ $RESET -ne 0 ] || [ $ACCEPT_COUNTRY_CODE -a $($IPTABLES -nL COUNTRY_FILTER 2>/dev/null | awk 'END{print NR}') -le 2 ] || [ $DROP_COUNTRY_CODE -a $($IPTABLES -nL BLACKLIST_COUNTRY 2>/dev/null | awk 'END{print NR}') -le 2 ]; then
    echo "BUILD:		Chain COUNTRY_FILTER"

    $IPTABLES -F COUNTRY_FILTER 2>/dev/null
    $IPTABLES -X COUNTRY_FILTER 2>/dev/null
    $IPTABLES -N COUNTRY_FILTER 2>/dev/null

    $IPTABLES -F BLACKLIST_COUNTRY 2>/dev/null
    $IPTABLES -X BLACKLIST_COUNTRY 2>/dev/null
    $IPTABLES -N BLACKLIST_COUNTRY 2>/dev/null

    BUILD_COUNTRY "delegated-apnic-extended-latest"   $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-arin-extended-latest"    $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-ripencc-extended-latest" $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-lacnic-extended-latest"  $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE
    BUILD_COUNTRY "delegated-afrinic-extended-latest" $ACCEPT_COUNTRY_CODE $DROP_COUNTRY_CODE

    $IPTABLES -A COUNTRY_FILTER -j DROP
else
    [ $ACCEPT_COUNTRY_CODE ] && echo "REUSE:		Chain COUNTRY_FILTER"
    [ $DROP_COUNTRY_CODE ] && echo "REUSE:		Chain BLACKLIST_COUNTRY"
fi

if [ $DROP_COUNTRY_CODE ] && [ $($IPTABLES -nL BLACKLIST_COUNTRY 2>/dev/null | awk 'END{print NR}') -gt 2 ]; then
    $IPTABLES -A INPUT -j BLACKLIST_COUNTRY
    $IPTABLES -A FORWARD -j BLACKLIST_COUNTRY
    $IPTABLES -A OUTPUT -j BLACKLIST_COUNTRY
fi


#----------------------------------------------------------#
# Firewall                                                 #
#----------------------------------------------------------#

# 送信元IPの偽装防止
sed -i '/net.ipv4.conf.*.rp_filter/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.rp_filter=1 > /dev/null
    echo "net.ipv4.conf.$dev.rp_filter=1" >> /etc/sysctl.conf
done

# ICMP Redirectパケットを拒否
sed -i '/net.ipv4.conf.*.accept_redirects/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.accept_redirects=0 > /dev/null
    echo "net.ipv4.conf.$dev.accept_redirects=0" >> /etc/sysctl.conf
done

# Source Routedパケットを拒否
sed -i '/net.ipv4.conf.*.accept_source_route/d' /etc/sysctl.conf
for dev in `ls /proc/sys/net/ipv4/conf/`
do
    sysctl -w net.ipv4.conf.$dev.accept_source_route=0 > /dev/null
    echo "net.ipv4.conf.$dev.accept_source_route=0" >> /etc/sysctl.conf
done

# ブロードキャストアドレス宛pingには応答しない
# ※Smurf攻撃対策
sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1 > /dev/null
sed -i '/net.ipv4.icmp_echo_ignore_broadcasts/d' /etc/sysctl.conf
echo "net.ipv4.icmp_echo_ignore_broadcasts=1" >> /etc/sysctl.conf

# SYN Cookiesを有効にする
# ※TCP SYN Flood攻撃対策
sysctl -w net.ipv4.tcp_syncookies=1 > /dev/null
sed -i '/net.ipv4.tcp_syncookies/d' /etc/sysctl.conf
echo "net.ipv4.tcp_syncookies=1" >> /etc/sysctl.conf

# システムの連続稼働時間を通知しない
# ※カーネルバージョン特定対策
sysctl -w net.ipv4.tcp_timestamps=1 > /dev/null
sed -i '/net.ipv4.tcp_timestamps/d' /etc/sysctl.conf
echo "net.ipv4.tcp_timestamps=1" >> /etc/sysctl.conf

# ブロードキャストパケットをログを記録せずに破棄
$IPTABLES -N DENY_BROADCAST
$IPTABLES -A DENY_BROADCAST -j DROP
$IPTABLES -N FW_BROADCAST
$IPTABLES -A FW_BROADCAST -g OUTBOUND_RETURN
$IPTABLES -A FW_BROADCAST -m pkttype --pkt-type broadcast -j DENY_BROADCAST
$IPTABLES -A FIREWALL -j FW_BROADCAST && echo "FIREWALL:	DENY_BROADCAST		INBOUND"

# マルチキャストパケットをログを記録せずに破棄
$IPTABLES -N DENY_MULTICAST
$IPTABLES -A DENY_MULTICAST -j DROP
$IPTABLES -N FW_MULTICAST
$IPTABLES -A FW_MULTICAST -g OUTBOUND_RETURN
$IPTABLES -A FW_MULTICAST -m pkttype --pkt-type multicast -j DENY_MULTICAST
$IPTABLES -A FIREWALL -j FW_MULTICAST && echo "FIREWALL:	DENY_MULTICAST		INBOUND"

# 不正なアクセスを行ったIPからのすべてのアクセスをログを記録して破棄
# ※調査的アクセスから公開ポートを隠蔽する
# ※公表サーバーでは無効にしてよい
$IPTABLES -N ANTI_SPY
$IPTABLES -A ANTI_SPY -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SPY] : '
$IPTABLES -A ANTI_SPY -j DROP
$IPTABLES -N FW_SPY
# 公表サーバーでは既知のポートはフィルタしない
$IPTABLES -A FW_SPY -g OUTBOUND_RETURN
$IPTABLES -A FW_SPY -p tcp --dport 0:1023 -j RETURN
$IPTABLES -A FW_SPY -p tcp -m state --state ESTABLISHED,RELATED -j RETURN
$IPTABLES -A FW_SPY -m limit --limit 1000/s --limit-burst 10000 -m recent --name spy-rapid --update --rttl -j ANTI_SPY
$IPTABLES -A FW_SPY -m limit --limit 1000/s --limit-burst 10000 -m recent --name spy-fast --update --rttl -j ANTI_SPY
$IPTABLES -A FW_SPY -m limit --limit 1000/s --limit-burst 10000 -m recent --name spy-medium --update --rttl -j ANTI_SPY
$IPTABLES -A FW_SPY -m limit --limit 1000/s --limit-burst 10000 -m recent --name spy-slow --update --rttl -j ANTI_SPY
$IPTABLES -A FIREWALL -j FW_SPY && echo "FIREWALL:	ANTI_SPY		INBOUND"
# recentモジュールは初期値で100IPしか記憶できない
# 送信元を偽装したパケットを大量に送りつけるか調査元の絶対数が増えると容易に無効化されるため対処されれば効果はない
# 攻撃価値の不明なIPの存在確認とポートスキャンに必要となる最小コストを上げる防御としては有効
# 管理機能を持つサーバーは攻撃価値を特定され本格的な攻撃を受けないよう非公表サーバーに分離隠蔽する必要がある
# $ vi /etc/modprobe.d/iptables-recent.conf
# options ip_list_hash_size=0 xt_recent ip_list_tot=1000
# $ reboot
# $ cat /sys/module/xt_recent/parameters/ip_list_tot
# $ ls /proc/net/xt_recent/

# 不審なアクセスを行っているIPをスパイとして記録
# ※不審なアクセスを長時間追跡する
# ※正規の通信のフィルタとして使用不可
# ※公表サーバーでは無効にしてよい
$IPTABLES -N ANTI_PROWLER_RAPID
$IPTABLES -A ANTI_PROWLER_RAPID -m recent --name spy-rapid --update --rttl -j DROP
$IPTABLES -A ANTI_PROWLER_RAPID -m recent --name spy-rapid --set -j DROP
$IPTABLES -N ANTI_PROWLER_FAST
$IPTABLES -A ANTI_PROWLER_FAST -m recent --name spy-fast --update --rttl -j DROP
$IPTABLES -A ANTI_PROWLER_FAST -m recent --name spy-fast --set -j DROP
$IPTABLES -N ANTI_PROWLER_MEDIUM
$IPTABLES -A ANTI_PROWLER_MEDIUM -m recent --name spy-medium --update --rttl -j DROP
$IPTABLES -A ANTI_PROWLER_MEDIUM -m recent --name spy-medium --set -j DROP
$IPTABLES -N ANTI_PROWLER_SLOW
$IPTABLES -A ANTI_PROWLER_SLOW -m recent --name spy-slow --update --rttl -j DROP
$IPTABLES -A ANTI_PROWLER_SLOW -m recent --name spy-slow --set -j DROP
$IPTABLES -N FW_PROWLER
$IPTABLES -A FW_PROWLER -g OUTBOUND_RETURN
$IPTABLES -A FW_PROWLER \
          -m hashlimit \
          --hashlimit-name prowler-limit \
          --hashlimit-above 1/s \
          --hashlimit-burst 1 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 800 \
          -j DROP
$IPTABLES -N FW_PROWLER_LIMIT
$IPTABLES -A FW_PROWLER_LIMIT -m limit --limit 1000/s --limit-burst 10000 -j RETURN
$IPTABLES -A FW_PROWLER_LIMIT -j DROP
$IPTABLES -A FW_PROWLER -j FW_PROWLER_LIMIT
$IPTABLES -A FW_PROWLER \
          -m hashlimit \
          --hashlimit-name prowler-rapid \
          --hashlimit-above 1/s \
          --hashlimit-burst 1 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 1000 \
          -j ANTI_PROWLER_RAPID
$IPTABLES -A FW_PROWLER -m recent --name spy-rapid --set
$IPTABLES -A FW_PROWLER \
          -m hashlimit \
          --hashlimit-name prowler-fast \
          --hashlimit-above 1/h \
          --hashlimit-burst 1 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 100000 \
          -j ANTI_PROWLER_FAST
$IPTABLES -A FW_PROWLER -m recent --name spy-fast --set
$IPTABLES -A FW_PROWLER \
          -m hashlimit \
          --hashlimit-name prowler-medium \
          --hashlimit-above 1/h \
          --hashlimit-burst 1 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 1000000 \
          -j ANTI_PROWLER_MEDIUM
$IPTABLES -A FW_PROWLER -m recent --name spy-medium --set
$IPTABLES -A FW_PROWLER \
          -m hashlimit \
          --hashlimit-name prowler-slow \
          --hashlimit-above 1/d \
          --hashlimit-burst 1 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 10000000 \
          -j ANTI_PROWLER_SLOW
$IPTABLES -A FW_PROWLER -m recent --name spy-slow --set
$IPTABLES -A FW_PROWLER -j DROP

# 送信元IPアドレスがLANネットワーク範囲外のパケットをログを記録して破棄してNG
# ※Ingress攻撃対策
$IPTABLES -N ANTI_INGRESS
$IPTABLES -A ANTI_INGRESS -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES INGRESS] : '
$IPTABLES -A ANTI_INGRESS -j FW_PROWLER
$IPTABLES -A ANTI_INGRESS -j DROP
$IPTABLES -N FW_INGRESS
$IPTABLES -A FW_INGRESS -g OUTBOUND_RETURN
$IPTABLES -A FW_INGRESS -i $LAN ! -s $LOCALNET -j ANTI_INGRESS
$IPTABLES -A FORWARD -j FW_INGRESS && echo "FIREWALL:	ANTI_INGRESS		FORWARD(INBOUND)"

# WANからの送信元がプライベートIPアドレスのパケットをログを記録して破棄してNG
# ※IP spoofing攻撃対策
$IPTABLES -N ANTI_SPOOFING
$IPTABLES -A ANTI_SPOOFING -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SPOOFING] : '
$IPTABLES -A ANTI_SPOOFING -j FW_PROWLER
$IPTABLES -A ANTI_SPOOFING -j DROP
$IPTABLES -N FW_SPOOFING
$IPTABLES -A FW_SPOOFING -g OUTBOUND_RETURN
$IPTABLES -A FW_SPOOFING -s 127.0.0.0/8    -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 10.0.0.0/8     -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 172.16.0.0/12  -j ANTI_SPOOFING
$IPTABLES -A FW_SPOOFING -s 192.168.0.0/16 -j ANTI_SPOOFING
$IPTABLES -A FIREWALL -j FW_SPOOFING && echo "FIREWALL:	ANTI_SPOOFING		INBOUND"

# 外部とのNetBIOS関連のアクセスはログを記録せずに破棄してNG
$IPTABLES -N DENY_NETBIOS
$IPTABLES -A DENY_NETBIOS -j FW_PROWLER
$IPTABLES -A DENY_NETBIOS -j DROP
$IPTABLES -N FW_NETBIOS
$IPTABLES -A FW_NETBIOS -p tcp -m multiport --dports 135,137,138,139,445 -j DENY_NETBIOS
$IPTABLES -A FW_NETBIOS -p udp -m multiport --dports 135,137,138,139,445 -j DENY_NETBIOS
$IPTABLES -A FIREWALL -j FW_NETBIOS && echo "FIREWALL:	DENY_NETBIOS		ALL"

# フラグメント化されたパケットをログを記録して破棄してNG
$IPTABLES -N DENY_FRAGMENT
$IPTABLES -A DENY_FRAGMENT -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES FRAGMENT] : '
$IPTABLES -A DENY_FRAGMENT -j FW_PROWLER
$IPTABLES -A DENY_FRAGMENT -j DROP
$IPTABLES -N FW_FRAGMENT
$IPTABLES -A FW_FRAGMENT -g OUTBOUND_RETURN
$IPTABLES -A FW_FRAGMENT -f -j DENY_FRAGMENT
$IPTABLES -A FIREWALL -j FW_FRAGMENT && echo "FIREWALL:	DENY_FRAGMENT		INBOUND"

# 不正なパケットをログを記録して破棄してNG
$IPTABLES -N DENY_INVALID
$IPTABLES -A DENY_INVALID -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES INVALID] : '
$IPTABLES -A DENY_INVALID -j DROP
$IPTABLES -N FW_INVALID
$IPTABLES -A FW_INVALID -g OUTBOUND_RETURN
$IPTABLES -A FW_INVALID -m state --state INVALID -j DENY_INVALID
$IPTABLES -A FIREWALL -j FW_INVALID && echo "FIREWALL:	DENY_INVALID		INBOUND"

# フラグの不正なパケットを破棄、1時間に3回を超えたらログを記録してNG
# ※ステルススキャン対策
# ※既知のポートはもともと隠密性がないため保護せず誤作動の回避を優先
# ※SSHの終了処理をしないで切断されると簡単に自爆するので注意
# ※FW_PORTSCANとFW_SPYが機能しているうちは有効にする必要性は低い
# ※フラグパターンの妥当性未検証
# ※公表サーバーでは無効にしてよい
$IPTABLES -N ANTI_STEALTHSCAN
$IPTABLES -A ANTI_STEALTHSCAN \
          -m hashlimit \
          --hashlimit-name scan \
          --hashlimit 1/h \
          --hashlimit-burst 3 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 960000 \
          -j DROP
$IPTABLES -A ANTI_STEALTHSCAN -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES STEALTHSCAN] : '
$IPTABLES -A ANTI_STEALTHSCAN -j FW_PROWLER
$IPTABLES -A ANTI_STEALTHSCAN -j DROP
$IPTABLES -N FW_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -g OUTBOUND_RETURN
$IPTABLES -A FW_STEALTHSCAN ! -p tcp -j RETURN
$IPTABLES -A FW_STEALTHSCAN -p tcp --dport 0:1023 -j RETURN
$IPTABLES -A FW_STEALTHSCAN -p tcp -m state ! --state NEW -j RETURN
# SYN + ACK when NEW
$IPTABLES -A FW_STEALTHSCAN -p tcp -m state --state NEW --tcp-flags SYN,ACK SYN,ACK -j ANTI_STEALTHSCAN
# FIN/PSH/URG without ACK
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,FIN FIN -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,PSH PSH -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ACK,URG URG -j ANTI_STEALTHSCAN
# SYN + FIN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags SYN,FIN SYN,FIN -j ANTI_STEALTHSCAN
# SYN + RST
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags SYN,RST SYN,RST -j ANTI_STEALTHSCAN
# FIN + RST
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags FIN,RST FIN,RST -j ANTI_STEALTHSCAN
# ALL
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL ALL -j ANTI_STEALTHSCAN
# nmap Null scans / no flags
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL NONE -j ANTI_STEALTHSCAN
# nmap FIN stealth scan
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL FIN -j ANTI_STEALTHSCAN
# FIN + URG + PSH
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL FIN,PSH,URG -j ANTI_STEALTHSCAN
# XMAS
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j ANTI_STEALTHSCAN
$IPTABLES -A FW_STEALTHSCAN -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG,PSH -j ANTI_STEALTHSCAN
$IPTABLES -A FIREWALL -j FW_STEALTHSCAN && echo "FIREWALL:	ANTI_STEALTHSCAN	INBOUND"

# pingは1秒間に4回を超えたらログを記録して破棄してNG
# ※Ping of Death攻撃対策
$IPTABLES -N ANTI_PINGDEATH
$IPTABLES -A ANTI_PINGDEATH \
          -m hashlimit \
          --hashlimit-name ping \
          --hashlimit 1/s \
          --hashlimit-burst 4 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 1000 \
          -j RETURN
$IPTABLES -A ANTI_PINGDEATH -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES PINGDEATH] : '
$IPTABLES -A ANTI_PINGDEATH -j FW_PROWLER
$IPTABLES -A ANTI_PINGDEATH -j DROP
$IPTABLES -N FW_PINGDEATH
$IPTABLES -A FW_PINGDEATH -g OUTBOUND_RETURN
$IPTABLES -A FW_PINGDEATH -p icmp --icmp-type echo-request -j ANTI_PINGDEATH
$IPTABLES -A FIREWALL -j FW_PINGDEATH && echo "FIREWALL:	ANTI_PINGDEATH		INBOUND"

# 過大なアクセスをIP単位で制限
# ※SYN Flood攻撃対策(数値は適宜調整)
#
# -m hashlimit                 ：hashlimitモジュールを利用
# --hashlimit-name name        ：ハッシュテーブル名
# --hashlimit n                ：パケット回復量
# --hashlimit-burst n          ：パケット容量
# --hashlimit-mode hash        ：同一アクセスとしてカウントする識別基準
# --hashlimit-htable-expire ms ：ハッシュテーブル内のレコードの有効期間(単位：ミリ秒)
#
# HTTPポートへの過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_SYNFLOOD
$IPTABLES -A ANTI_SYNFLOOD \
          -m hashlimit \
          --hashlimit-name http \
          --hashlimit 10/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_SYNFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SYNFLOOD] : '
$IPTABLES -A ANTI_SYNFLOOD -j DROP
$IPTABLES -N FW_SYNFLOOD
$IPTABLES -A FW_SYNFLOOD -g OUTBOUND_RETURN
$IPTABLES -A FW_SYNFLOOD -p tcp --dport 80 -m state --state NEW -j ANTI_SYNFLOOD
$IPTABLES -A FIREWALL -j FW_SYNFLOOD && echo "FIREWALL:	ANTI_SYNFLOOD		INBOUND[TCP:80]"
#
# HTTPSポートへの過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_SYNFLOOD_SSL
$IPTABLES -A ANTI_SYNFLOOD_SSL \
          -m hashlimit \
          --hashlimit-name https \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_SYNFLOOD_SSL -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES SYNFLOOD(SSL)] : '
$IPTABLES -A ANTI_SYNFLOOD_SSL -j DROP
$IPTABLES -N FW_SYNFLOOD_SSL
$IPTABLES -A FW_SYNFLOOD_SSL -g OUTBOUND_RETURN
$IPTABLES -A FW_SYNFLOOD_SSL -p tcp --dport 443 -m state --state NEW -j ANTI_SYNFLOOD_SSL
$IPTABLES -A FIREWALL -j FW_SYNFLOOD_SSL && echo "FIREWALL:	ANTI_SYNFLOOD_SSL	INBOUND[TCP:443]"
#
# UDPによる過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_UDPFLOOD
$IPTABLES -A ANTI_UDPFLOOD \
          -m hashlimit \
          --hashlimit-name udp \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_UDPFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES UDPFLOOD] : '
$IPTABLES -A ANTI_UDPFLOOD -j DROP
$IPTABLES -N FW_UDPFLOOD
$IPTABLES -A FW_UDPFLOOD -g OUTBOUND_RETURN
$IPTABLES -A FW_UDPFLOOD -p udp -m state --state NEW -j ANTI_UDPFLOOD
$IPTABLES -A FIREWALL -j FW_UDPFLOOD && echo "FIREWALL:	ANTI_UDPFLOOD		INBOUND[UDP]"
#
# ICMPによる過大なアクセスをログを記録して破棄
$IPTABLES -N ANTI_ICMPFLOOD
$IPTABLES -A ANTI_ICMPFLOOD \
          -m hashlimit \
          --hashlimit-name icmp \
          --hashlimit 30/m \
          --hashlimit-burst 60 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 60000 \
          -j RETURN
$IPTABLES -A ANTI_ICMPFLOOD -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES ICMPFLOOD] : '
$IPTABLES -A ANTI_ICMPFLOOD -j DROP
$IPTABLES -N FW_ICMPFLOOD
$IPTABLES -A FW_ICMPFLOOD -g OUTBOUND_RETURN
$IPTABLES -A FW_ICMPFLOOD -p icmp --icmp-type echo-request -j ANTI_ICMPFLOOD
$IPTABLES -A FIREWALL -j FW_ICMPFLOOD && echo "FIREWALL:	ANTI_ICMPFLOOD		INBOUND[ICMP]"

# 管理用ポートへ3分間に10回を超えて接続試行をログを記録して破棄してNG
# ※Brute Force攻撃対策
$IPTABLES -N ANTI_BRUTEFORCE
$IPTABLES -A ANTI_BRUTEFORCE \
          -m hashlimit \
          --hashlimit-name bruteforce \
          --hashlimit 1/m \
          --hashlimit-burst 7 \
          --hashlimit-mode srcip \
          --hashlimit-htable-expire 180000 \
          -j RETURN
$IPTABLES -A ANTI_BRUTEFORCE -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES BRUTEFORCE] : '
$IPTABLES -A ANTI_BRUTEFORCE -j FW_PROWLER
$IPTABLES -A ANTI_BRUTEFORCE -j DROP
$IPTABLES -N FW_BRUTEFORCE
$IPTABLES -A FW_BRUTEFORCE -g OUTBOUND_RETURN
$IPTABLES -A FW_BRUTEFORCE -p tcp -m multiport --dports $LOGIN -m state --syn --state NEW -j ANTI_BRUTEFORCE
$IPTABLES -A FIREWALL -j FW_BRUTEFORCE && echo "FIREWALL:	ANTI_BRUTEFORCE		INBOUND[TCP]"


#----------------------------------------------------------#
# BLACKLIST/GRAYLIST/WHITELIST                             #
#----------------------------------------------------------#

# ブラックリストに一致するIPをDROPする
$IPTABLES -N BLACKLIST
if [ $BLACKLIST ] && [ -s $BLACKLIST ]; then
  for line in `cat $BLACKLIST | grep ^[0-9]`
  do
    $IPTABLES -A BLACKLIST -s $line -j DROP
  done

  $IPTABLES -I INPUT -j BLACKLIST
  $IPTABLES -I FORWARD -j BLACKLIST
  $IPTABLES -I OUTPUT -j BLACKLIST
fi

# グレーリストに一致するIPをFIREWALLへ転送する
$IPTABLES -N GRAYLIST
if [ $GRAYLIST ] && [ -s $GRAYLIST ]; then
  for line in `cat $GRAYLIST | grep ^[0-9]`
  do
    $IPTABLES -A GRAYLIST -s $line -j FIREWALL
  done

  $IPTABLES -I INPUT -j GRAYLIST
  $IPTABLES -I FORWARD -j GRAYLIST
  $IPTABLES -I OUTPUT -j GRAYLIST
fi

# ホワイトリストに一致するIPをACCEPTする
$IPTABLES -N WHITELIST
if [ $WHITELIST ] && [ -s $WHITELIST ]; then
  for line in `cat $WHITELIST | grep ^[0-9]`
  do
    $IPTABLES -A WHITELIST -s $line -j ACCEPT
  done

  $IPTABLES -I INPUT -j WHITELIST
  $IPTABLES -I FORWARD -j WHITELIST
  $IPTABLES -I OUTPUT -j WHITELIST

  $IPTABLES -A WHITELIST -j DROP
fi


#----------------------------------------------------------#
# IDS/IPS                                                  #
#----------------------------------------------------------#

if [ $IPS = Snort ]; then

    # ICMPパケットをすべて解析
    $IPTABLES -A FIREWALL -p icmp -j NFQUEUE --queue-num 2

    # UDPパケットをすべて解析
    $IPTABLES -A FIREWALL -p udp -j NFQUEUE --queue-num 2

    # TCPパケットを外部通信分のみ解析
    $IPTABLES -A FIREWALL -i eth+ -p tcp -j NFQUEUE --queue-num 2
    $IPTABLES -A FIREWALL -i ppp+ -p tcp -j NFQUEUE --queue-num 2
    $IPTABLES -A FIREWALL -o eth+ -p tcp -j NFQUEUE --queue-num 2
    $IPTABLES -A FIREWALL -o ppp+ -p tcp -j NFQUEUE --queue-num 2

    # バックエンドサーバーとの内部通信パケットを解析
    $IPTABLES -A FIREWALL -i lo -p tcp --dport 9000 -j NFQUEUE --queue-num 2
    $IPTABLES -A FIREWALL -o lo -p tcp --dport 9000 -j NFQUEUE --queue-num 2

    # 解析しないパケットはすべて許可
    $IPTABLES -A FIREWALL -j ACCEPT

    echo "IDS/IPS:	Snort"

else
    $IPTABLES -A FIREWALL -j ACCEPT
    echo "IDS/IPS:	DISABLE"
fi

# 一時設定を除去
$IPTABLES -D FIREWALL 1


#----------------------------------------------------------#
# Port                                                     #
#----------------------------------------------------------#

# 最小限のICMPのみ許可
$IPTABLES -A INPUT -p icmp --icmp-type destination-unreachable -j COUNTRY_FILTER
$IPTABLES -A INPUT -p icmp --icmp-type source-quench -j COUNTRY_FILTER
$IPTABLES -A INPUT -p icmp --icmp-type redirect -j COUNTRY_FILTER
$IPTABLES -A INPUT -p icmp --icmp-type time-exceeded -j COUNTRY_FILTER
$IPTABLES -A INPUT -p icmp --icmp-type parameter-problem -j COUNTRY_FILTER

# 管理用ポート(SSH等)を開放
$IPTABLES -A INPUT -p tcp -m multiport --dports $LOGIN -j COUNTRY_FILTER

# SNMP[UDP:160,161]ポートを開放
#$IPTABLES -A INPUT -p udp --dport 160 -j COUNTRY_FILTER && echo "SERVICE:	SNMP			[UDP:160]"
#$IPTABLES -A INPUT -p udp --dport 161 -j COUNTRY_FILTER && echo "SERVICE:	SNMP			[UDP:161]"

# DNS[TCP/UDP:53]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 53 -j COUNTRY_FILTER && echo "SERVICE:	DNS			[TCP:53]"
#$IPTABLES -A INPUT -p udp --dport 53 -j COUNTRY_FILTER && echo "SERVICE:	DNS			[UDP:53]"

# HTTP[TCP:80]ポートを開放
$IPTABLES -A INPUT -p tcp --dport 80 -j FIREWALL && echo "SERVICE:	HTTP			[TCP:80]"

# HTTPS[TCP:443]ポートを開放
$IPTABLES -A INPUT -p tcp --dport 443 -j COUNTRY_FILTER && echo "SERVICE:	HTTPS			[TCP:443]"

# FTP[TCP:21]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 21 -j COUNTRY_FILTER

# PASV(FTP-DATA)ポートを開放 ※PASV用ポート60000:60030は設定例
#$IPTABLES -A INPUT -p tcp --dport 60000:60030 -j COUNTRY_FILTER && echo "SERVICE:	PASV			[TCP:60000-60030]"

# IDENT[TCP:113]ポートを開放
# ※IDENTを使用せずメールサーバーを公開する場合はメールサーバ等のレスポンス低下防止のため拒否応答
#$IPTABLES -A INPUT -p tcp --dport 113 -j COUNTRY_FILTER && echo "SERVICE:	IDENT			[TCP:113]"
#$IPTABLES -A INPUT -p tcp --dport 113 -j REJECT --reject-with tcp-reset && echo "REJECT:	IDENT			[TCP:113]"

# SMTP[TCP:25]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 25 -j COUNTRY_FILTER && echo "SERVICE:	SMTP			[TCP:25]"

# SMTPS[TCP:465]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 465 -j COUNTRY_FILTER && echo "SERVICE:	SMTPS			[TCP:465]"

# POP3[TCP:110]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 110 -j COUNTRY_FILTER && echo "SERVICE:	POP3			[TCP:110]"

# POP3S[TCP:995]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 995 -j COUNTRY_FILTER && echo "SERVICE:	POP3S			[TCP:995]"

# IMAP[TCP:143]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 143 -j COUNTRY_FILTER && echo "SERVICE:	IMAP			[TCP:143]"

# IMAPS[TCP:993]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 993 -j COUNTRY_FILTER && echo "SERVICE:	IMAPS			[TCP:993]"

# OpenVPN[UDP:1194]ポートを開放
#$IPTABLES -A INPUT -p udp --dport 1194 -j COUNTRY_FILTER && echo "SERVICE:	OpenVPN			[UDP:1194]"

# IPsec[TCP/UDP:50,51]ポートを開放
#$IPTABLES -A INPUT -p 50 -j COUNTRY_FILTER && echo "SERVICE:	IPsec			[TCP/UDP:50]"
#$IPTABLES -A INPUT -p 51 -j COUNTRY_FILTER && echo "SERVICE:	IPsec			[TCP/UDP:51]"

# Submission[TCP:587]ポートを開放
#$IPTABLES -A INPUT -p tcp --dport 587 -j COUNTRY_FILTER && echo "SERVICE:	Submission			[TCP:587]"

# VPNインタフェース用ファイアウォール設定
#[ -f /etc/openvpn/openvpn-startup ] && /etc/openvpn/openvpn-startup

# 公開していないポートへのパケットをログを記録して破棄してNG
# ※ポートスキャン対策
# ※開けていないポートに1度でも触ったらアウト
# ※公表サーバーでは無効にしてよい
$IPTABLES -N TRAP_PORTSCAN
$IPTABLES -A TRAP_PORTSCAN -m limit --limit $LOG_LIMIT --limit-burst $LOG_LIMIT_BURST -j LOG --log-level debug --log-prefix '[IPTABLES PORTSCAN] : '
$IPTABLES -A TRAP_PORTSCAN -j FW_PROWLER
$IPTABLES -A TRAP_PORTSCAN -j DROP
$IPTABLES -N FW_PORTSCAN
$IPTABLES -A FW_PORTSCAN -g OUTBOUND_RETURN
$IPTABLES -A FW_PORTSCAN -j FW_BROADCAST
$IPTABLES -A FW_PORTSCAN -j FW_MULTICAST
$IPTABLES -A FW_PORTSCAN -j TRAP_PORTSCAN
$IPTABLES -A INPUT -j FW_PORTSCAN && echo "FIREWALL:	TRAP_PORTSCAN		INPUT"
$IPTABLES -A FORWARD -j FW_PORTSCAN && echo "FIREWALL:	TRAP_PORTSCAN		FORWARD(INBOUND)"


#----------------------------------------------------------#
# Finalize                                                 #
#----------------------------------------------------------#

# 設定保存(/etc/sysconfig/iptablesの既存の設定は削除)
service iptables save
sysctl -p 2>&1 | grep -v -E "^error:.*(ipv6|bridge-nf-call)"
service rsyslog restart

echo complete
